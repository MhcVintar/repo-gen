//go:build ignore

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

const repoTemplate = `// Code generated by go generate; DO NOT EDIT.
package repository

import (
	"errors"
	"github.com/mhcvintar/repo-gen/models"
	"gorm.io/gorm"
)

type {{.StructName}} struct {
	db *gorm.DB
}

var _ {{.InterfaceName}} = (*{{.StructName}})(nil)

func New{{.InterfaceName}}(db *gorm.DB) {{.InterfaceName}} {
	return &{{.StructName}}{
		db: db,
	}
}
{{range .Methods}}
func (r *{{$.StructName}}) {{.Name}}({{.ParamName}} {{.ParamType}}) (*models.{{$.ModelName}}, error) {
	var result models.{{$.ModelName}}
	dbResult := r.db.Where("{{.QueryField}} = ?", {{.ParamName}}).First(&result)
	if dbResult.Error != nil {
		if errors.Is(dbResult.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, dbResult.Error
	}
	return &result, nil
}
{{end}}
`

type Method struct {
	Name       string
	ParamName  string
	ParamType  string
	QueryField string
}

type Data struct {
	InterfaceName string
	StructName    string
	ModelName     string
	Methods       []Method
}

func main() {
	model := flag.String("model", "", "Model name")
	input := flag.String("input", "", "Input file with interface")
	flag.Parse()

	if *model == "" || *input == "" {
		panic("Usage: -model=User -input=user_repository.go")
	}

	fileSet := token.NewFileSet()
	node, err := parser.ParseFile(fileSet, *input, nil, 0)
	if err != nil {
		panic(err)
	}

	interfaceName := *model + "Repository"
	var methods []Method

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != interfaceName {
			return true
		}

		ifc, ok := typeSpec.Type.(*ast.InterfaceType)
		if !ok {
			return true
		}

		for _, method := range ifc.Methods.List {
			if len(method.Names) == 0 {
				continue
			}

			methodName := method.Names[0].Name
			
			if !strings.HasPrefix(methodName, "FindBy") {
				continue
			}

			funcType := method.Type.(*ast.FuncType)
			
			if funcType.Params == nil || len(funcType.Params.List) == 0 {
				continue
			}

			param := funcType.Params.List[0]
			paramName := param.Names[0].Name
			paramType := exprToString(param.Type)

			field := strings.TrimPrefix(methodName, "FindBy")
			queryField := toSnakeCase(field)

			methods = append(methods, Method{
				Name:       methodName,
				ParamName:  paramName,
				ParamType:  paramType,
				QueryField: queryField,
			})
		}

		return false
	})

	data := Data{
		InterfaceName: interfaceName,
		StructName:    strings.ToLower(*model) + "RepositoryImpl",
		ModelName:     *model,
		Methods:       methods,
	}

	t := template.Must(template.New("repo").Parse(repoTemplate))
	
	outFile, _ := os.Create(strings.ToLower(*model) + "_repository.gen.go")
	defer outFile.Close()

	t.Execute(outFile, data)
	
	fmt.Printf("Generated %d methods for %s\n", len(methods), interfaceName)
}

func exprToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + exprToString(t.X)
	case *ast.SelectorExpr:
		return exprToString(t.X) + "." + t.Sel.Name
	default:
		return ""
	}
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}